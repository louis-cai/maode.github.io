---
title: Java 堆、栈、方法区、几种常量池，String
date: 2017-09-19 15:32:41
tags:
	- heap、stack
	- 堆、栈
	- 常量池
	- String
---
**在JAVA中，数据的交互存在于以下地方：**

**寄存器（register）：** 位于CPU。
**栈（stack）：** 位于RAM。
**堆（heap）：** 位于RAM。
**方法区（PermGen）：** 位于RAM。
**非RAM存储：** 如硬盘等其它存储空间。

**就速度来说，从快到慢依次为： 寄存器 >栈 > 堆 > 其它。**


**JAVA的JVM的内存可分为3个区：`栈(stack)`、`堆(heap)`和`方法区(PermGen)`也叫永久代。**

<!-- more -->

## **寄存器（register）**
 这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但是寄存器的数量极其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。    

+ 最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制.

## **栈（stack）**
位于通用RAM中，但通过它的“栈指针”可以从处理器哪里获得支持。栈指针若向下移动，则分配新的内存；若向上移动，则释放那些 内存。这是一种快速有效的分配存储方法，仅次于寄存器。程序编译时，JAVA编译器必须知道存储在栈内所有数据的确切大小和生命周期，因为它必须生成相应的代码，以便上下移动栈指针。这一约束限制了程序的灵活性。    

+ **每个线程包含一个栈区**，栈中只存放**局部变量**[^1]（包含基本类型和引用类型）。因为基本类型变量的变量值存的是字面[值]，是 基本类型【原始类型|值类型】,所以大小可知。如`int a = 3;`[^2] 这里的a是一个int类型的变量，指向`3`这个值。这些字面值的数据，由于大小可知，生存期可知【这些字面值固定定义在某个程序块里面，程序块退出后，字面值生存期就结束了】，出于追求速度的原因，就存在于栈中了，而对象由于大小不可知，所以栈中只存放了对象的引用。

+ 每个栈中的数据都是私有的，其他栈不能访问。

+ 栈中的**基本类型**变量值在该栈中是可以被共享的（共享性质有点`类似`字符串常量池，相同的值只会被创建一次）。如：
  ``` java
  int a=3;
  int b=3;
  ```
  编译器先处理`int a = 3；`首先它会在栈中创建一个 [变量] a，然后查找栈中是否有3这个值，如果没找到，就在栈中开辟一块空间将3这个值存放进来，然后将a指向3的地址。接着处理`int b = 3；`在创建完b的变量后，因为在栈中已经有3这个值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。 特 别注意的是，这种基本类型的变量与引用类型的变量不同。假定两个引用类型的变量同时指向一个对象，如果一个变量修改了这个对象的内部状态，那么另一个变量也即刻反映出这个变化。相反，如果是两个基本类型的变量，修改其中一个的值，不会导致另一个指向此字面值的变量也跟着改变的情况。如上例，我们定义完a与 b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。

## **堆（heap）**
一种通用性的内存池（也存在于RAM中），用于存放所有的JAVA对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆中。堆不同于栈的好处是：编译器不需要知道要从堆里分配多少存储区域，也不必知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。当没有引用指向该对象时，垃圾回收机制会在恰当的时候将其回收掉。当然，为这种灵活性必须要付出相应的代价。用堆进行存储分配比用栈进行存储需要更多的时间。  

+  **jvm只有一个堆区(heap)，该区域被所有线程共享。** 存储的全部是对象实例。堆中不存放`基本类型`和`对象的引用`，只存放对象本身，[**几乎**]所有的 `对象实例` 和 `数组` 都在堆中分配。

## **方法区（PermGen）**
又叫永久代，跟堆一样，**被所有的线程共享**。它用于存储已经被虚拟机加载的`类信息`、`常量`、`静态变量`、`即时编译器编译后的代码`等数据。

+ JDK7之前 `运行时常量池` `字符串常量池` 还有很多[元数据](#关于java的元数据)都在方法区。

+ JDK7开始执行 PermGen移除（去永久代）计划，JDK8彻底移除PermGen。

+ JDK8彻底移除PermGen后，原本方法区中的这些对象被挪到GC堆外的一块叫做Metaspace的空间里做特殊管理，仍然间接的受GC管理。

## **非RAM存储**
如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。

# 几种常量池介绍
## **Class文件常量池**
存在于java文件编译完成后的class文件中。
这里面主要存放两大类常量：

字面量(Literal)：用双引号引起来的字符串等。

符号引用(Symbolic References)：属于编译原理方面的概念，包含三类常量：

+ 类和接口的全限定名(Full Qualified Name)

+ 字段的名称和描述符(Descriptor)

+ 方法的名称和描述符

这个用[javap](170921-javap)看一下就能明白，这里只涉及字符串就不谈其他的了。

## **运行时常量池**
class文件常量池在类加载后的产物，class文件常量池中的数据 在类加载后进入运行时常量池。

## **字符串常量池**
HotSpot VM里，记录interned string的一个全局表叫做StringTable，它本质上就是个HashSet<String>，是HotSpot VM里用来实现字符串驻留功能的全局数据结构。这是个纯运行时的结构，而且是惰性（lazy）维护的。注意它只存储对java.lang.String实例的引用，而不存储String对象的内容。 注意，它只存了引用，根据这个引用可以得到具体的String对象。

一般我们说一个字符串进入了全局的字符串常量池其实是说在这个StringTable中保存了对它的引用，反之，如果说没有在其中就是说StringTable中没有对它的引用。

JVM层面触发的字符串驻留（例如把Class文件里的CONSTANT_String类型常量转换为运行时对象），以及Java代码主动触发的字符串驻留（java.lang.String.intern()），两种请求都由StringTable来处理。

单开 好好唠唠

## **关于 String**
单开 好好唠唠


## **附录：**

### 关于java的元数据

HotSpot VM里有一套对象专门用来存放元数据，它们包括： 

*   Klass系对象。元数据的最主要入口。用于描述类型的总体信息
*   ConstantPool/ConstantPoolCache对象。每个InstanceKlass关联着一个ConstantPool，作为该类型的运行时常量池。这个常量池的结构跟Class文件里的常量池基本上是对应的。可以参考[R大以前的一个回帖](http://hllvm.group.iteye.com/group/topic/26412#post-187861)。ConstantPoolCache主要用于存储某些字节码指令所需的解析（resolve）好的常量项，例如给[get|put]static、[get|put]field、invoke[static|special|virtual|interface|dynamic]等指令对应的常量池项用。
*   Method对象，用来描述Java方法的总体信息，像是方法入口地址、调用/循环计数器等等
*   ConstMethod对象，记录着Java方法的不变的描述信息，包括方法名、方法的访问修饰符、**字节码**、行号表、局部变量表等等。注意了，字节码就嵌在这ConstMethod对象里面。
*   Symbol对象，对应Class文件常量池里的JVM_CONSTANT_Utf8类型的常量。有一个VM全局的SymbolTable管理着所有Symbol。Symbol由所有Java类所共享。
*   MethodData对象，记录着Java方法执行时的profile信息，例如某方法里的某个字节码之类是否从来没遇到过null，某个条件跳转是否总是走同一个分支，等等。这些信息在解释器（多层编译模式下也在低层的编译生成的代码里）收集，然后供给HotSpot Server Compiler用于做激进优化。

在PermGen移除前，上述元数据对象都在PermGen里，直接被GC管理着。 
JDK8彻底移除PermGen后，这些对象被挪到GC堆外的一块叫做Metaspace的空间里做特殊管理，仍然间接的受GC管理。

暂时就这些，后面没有了！(=^ ^=)


[^1]: 变量是变量，变量名是变量名，变量值是变量值，对象是对象，对象的引用是对象的引用。这个一定要搞清楚。变量 由: ***“一个包含部分已知或未知数值或资讯（即一个[值]）之[储存位址]”*** —— 变量值，以及 ***“相对应之[符号名称]（[识别字]）”*** —— 变量名，组成。如：`int a = 1;`a变量 的变量名为符号 ‘a’ ，变量值为[值] ‘3’。`Test t = new Test();` t变量 的变量名为符号 ‘t’ ，变量值为一个Test对象在内存中的存储位置（即对象的引用）。

[^2]: int有class但不是类,其它基本类型也是如此，int.class对应的Class对象是JVM合成出来的，并不是从Class文件加载出来的，在JVM初始化的时候就会把原始类型和void对应的Class对象创建出来。这些Class对象的创建不依赖任何外部信息，(例如说需要从Class文件加载的信息)，不需要经历类加载过程，而纯粹是JVM的实现细节。


[变量]: https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)#.E5.9C.A8.E6.BA.90.E4.BB.A3.E7.A0.81.E4.B8.AD
[值]: https://zh.wikipedia.org/wiki/%E5%80%BC_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)
[储存位址]: https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E4%BD%8D%E5%9D%80
[符号名称]: https://zh.wikipedia.org/wiki/%E7%AC%A6%E8%99%9F
[识别字]: https://zh.wikipedia.org/wiki/%E6%A8%99%E8%AD%98%E7%AC%A6
[字面量]: https://zh.wikipedia.org/wiki/%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F_(C%E8%AF%AD%E8%A8%80)